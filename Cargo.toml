[workspace]
members = ["canisters/fetcher"] # 指定工作空间

[profile.release]
# LTO顾名思义就是在程序编译后的链接阶段时所采取的优化行为，通常可以顺带减少编译出来的二进制文件的体积，
# 但也会显著增加编译时间和占用的内存，且有时对程序性能并没有正面的影响，所以Cargo程序项目在建置时缺省并没有激活LTO。
# Rust提供的LTO分为thin和fat两种，可以被视为两种不同的LTO实作，彼此编译出来的程序并没有绝对的性能优劣
# (在绝大部份情况下，打开LTO编译出来的程序之性能会比没打开LTO还要来得好)。但以编译速度来说，thin似乎总是比fat还要来得快。

# 在Cargo.toml的[profile.release]区块可以设置lto项目，在Release编译模式下激活LTO。
# 例如以下设置可以激活LTO(fat)：
# [profile.release]
# lto = true
# 此时使用Release模式编译crc64sum项目需要花1.867秒才能编译完成，最终产生的运行档大小只有1128 KB。

# 例如以下设置可以激活ThinLTO：
# [profile.release]
# lto = "thin"
# 此时使用Release模式编译crc64sum项目需要花1.466秒才能编译完成，最终产生的运行档大小只有1212 KB。

# 搭配opt-level = "s"或opt-level = "z"，还可以再让编译出来的文件变得更小。
lto = true

# Rust 会对代码进行何种程度的优化。这个配置的值从 0 到 3。
# 越高的优化级别需要更多的时间编译，所以如果你在进行开发并经常编译，可能会希望在牺牲一些代码性能的情况下编译得快一些。
# 这就是为什么 dev 的 opt-level 默认为 0。
# 当你准备发布时，花费更多时间在编译上则更好。只需要在发布模式编译一次，而编译出来的程序则会运行很多次，所以发布模式用更长的编译时间换取运行更快的代码。
# 这正是为什么 release 配置的 opt-level 默认为 3
# 0：不进行优化，并且激活#[cfg(debug_assertions)]属性。
# 1：允许基本优化。
# 2：允许常用的优化。
# 3：允许所有的优化。
# "s"：允许常用的优化，外加一些能缩小体积的优化。
# "z"：类似"s"，但更偏重于体积的优化(可能会降低性能)。
opt-level = 'z'

# 在Cargo.toml的[profile.release]区块可以设置codegen-units项目，来指定编译器在编译一个crate的时候要能其切分成多少份来同时处理。
# 默认值是16或256，若改成1，则不进行切分，以增加套用更多的优化的机会，提升程序性能，但可能会让编译时间上升。

# 例如以下设置：
# [profile.release]
# codegen-units = 1
# 此时使用Release模式编译crc64sum项目需要花0.746秒，最终产生的运行档大小为2804 KB。
codegen-units = 1


# inline
# Rust内置#[inline]属性，可以手动建议(非强制)编译器去对某个函数进行内联(inline)处理，将函数的实作展开(拷贝)至调用这个函数的地方。
# 内联的目的在于减少函数调用的次数，以避免创建堆栈框(Stack Frame)而有额外的开支(overhead)。
# 对于一个体积极小(例如只有一个表达式)、需要进行快速计算或是为使代码易读而从某个函数中切分出来的函数，
# 我们可以将其加上#[inline]属性，使它们在编译的时候可以在被调用的位置上展开。
# 另外还有#[inline(always)]属性，可以让编译器总是对该函数做内联，使其更像是类函数(funciton-like)宏。
# #[inline(never)]属性，则可以告诉编译器不对这个函数做内联的动作，方便调试。

# strip
# 不管是在Debug编译模式还是Release编译模式，编译好的二进制档都会带有调试信息。
# Unix-like环境下，通过Release编译模式编译出来的二进制档，可以再通过strip指令，将其中不必要的标头和调试信息移除。
# 例如crc64sum项目在使用缺省的Release编译模式进行建置后，可以再运行以下的指令：
# strip ./target/release/crc64sum
# 如下图，此时的运行档就只剩下252 KB了。
